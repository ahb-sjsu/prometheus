#!/usr/bin/env python3
"""
Hubris Design Pattern Detector
==============================
Detects misused design patterns that add complexity without benefit.

Categories:
- Singleton Abuse: Global mutable state, thread-unsafe singletons
- Factory Overkill: Over-abstracted factories, single-type factories
- God Objects: Classes with too many responsibilities
- Inheritance Abuse: Deep hierarchies, inheritance for code reuse
- Abstraction Astronauts: Over-engineered interfaces and abstractions
- Observer Leaks: Unsubscribed observers, circular dependencies
- Builder Bloat: Builders for simple objects
"""

import re

from .fp_filter import should_flag_match
from .models import DesignPatternIssue


def _is_test_file(filepath: str) -> bool:
    """Check if file is a test file."""
    from pathlib import Path

    path = Path(filepath)
    name = path.name.lower()
    parts = [p.lower() for p in path.parts]

    if name.startswith("test_") or name.endswith("_test.py"):
        return True
    if name.startswith("test.") or "spec." in name:
        return True
    if name in ("conftest.py", "fixtures.py"):
        return True

    test_dirs = {"tests", "test", "__tests__", "spec", "specs", "testing"}
    return bool(test_dirs & set(parts))


def _is_generated_file(filepath: str, content: str) -> bool:
    """Check if a file is generated code (skip analysis)."""
    from pathlib import Path

    generated_markers = [
        "# Generated by",
        "// Generated by",
        "/* Generated by",
        "# DO NOT EDIT",
        "// DO NOT EDIT",
        "# Auto-generated",
        "// Auto-generated",
        "@generated",
        "This file is auto-generated",
        "Code generated by",
    ]

    first_lines = "\n".join(content.split("\n")[:20])
    for marker in generated_markers:
        if marker.lower() in first_lines.lower():
            return True

    name = Path(filepath).name.lower()
    generated_names = {
        "package-lock.json",
        "yarn.lock",
        "poetry.lock",
        "go.sum",
        "cargo.lock",
        "gemfile.lock",
    }
    if name in generated_names:
        return True

    if "_pb2.py" in name or "_grpc.py" in name:
        return True
    if ".generated." in name or ".g." in name:
        return True

    return False


# =============================================================================
# DESIGN PATTERN REGEX PATTERNS
# =============================================================================

DESIGN_PATTERNS = {
    "python": {
        "singleton_decorator": re.compile(
            r"@singleton|def\s+__new__\s*\([^)]*cls[^)]*\).*?_instance", re.DOTALL
        ),
        "global_instance": re.compile(r"^[A-Z_][A-Z0-9_]*\s*=\s*\w+\(\)", re.MULTILINE),
        "module_singleton": re.compile(r"_instance\s*=\s*None.*?def\s+get_instance", re.DOTALL),
        "god_class_methods": re.compile(r"^\s+def\s+(?!__)\w+\s*\(", re.MULTILINE),
        "god_class_attrs": re.compile(r"self\.\w+\s*=", re.MULTILINE),
        "abstract_factory": re.compile(r"class\s+\w*(?:Abstract)?Factory|def\s+create_\w+\s*\("),
        "factory_if_chain": re.compile(
            r'(?:if|elif)\s+\w+\s*==\s*[\'"][^\'"]+[\'"]\s*:.*?return\s+\w+\(', re.DOTALL
        ),
        "deep_inheritance": re.compile(r"class\s+\w+\s*\(\s*\w+\s*\)"),
        "abstract_everything": re.compile(r"from\s+abc\s+import.*ABC|@abstractmethod"),
        "interface_explosion": re.compile(r"class\s+I[A-Z]\w*\s*\(.*?ABC\s*\)|Protocol\s*\)"),
        "builder_pattern": re.compile(r"class\s+\w*Builder|def\s+build\s*\(self\)|\.set_\w+\s*\("),
        "fluent_builder": re.compile(r"return\s+self\s*$", re.MULTILINE),
        "observer_subscribe": re.compile(r"\.subscribe\s*\(|\.add_observer\s*\(|\.register\s*\("),
        "observer_unsubscribe": re.compile(
            r"\.unsubscribe\s*\(|\.remove_observer\s*\(|\.unregister\s*\("
        ),
        "decorator_chain": re.compile(r"(?:@\w+\s*(?:\([^)]*\))?\s*\n){4,}"),
        "mixin_explosion": re.compile(r"class\s+\w+\s*\([^)]*,\s*[^)]*,\s*[^)]*,\s*[^)]*\)"),
    },
    "javascript": {
        "singleton_instance": re.compile(r"static\s+instance\s*[;=]|getInstance\s*\(\s*\)"),
        "module_singleton": re.compile(r"let\s+instance\s*=\s*null|const\s+instance\s*="),
        "global_singleton": re.compile(r"(?:window|global|globalThis)\.\w+\s*=\s*new\s+\w+"),
        "god_class_methods": re.compile(r"^\s+(?:async\s+)?\w+\s*\([^)]*\)\s*{", re.MULTILINE),
        "large_object": re.compile(r"(?:const|let|var)\s+\w+\s*=\s*\{[^}]{2000,}\}", re.DOTALL),
        "factory_function": re.compile(r"function\s+create\w+|const\s+create\w+\s*="),
        "factory_switch": re.compile(
            r'switch\s*\([^)]+\)\s*\{(?:[^}]*case\s+[\'"][^\'"]+[\'"]:\s*return\s+new\s+\w+){3,}',
            re.DOTALL,
        ),
        "extends_chain": re.compile(r"class\s+\w+\s+extends\s+\w+"),
        "interface_explosion": re.compile(r"interface\s+I[A-Z]\w*\s*(?:extends|\{)"),
        "abstract_class": re.compile(r"abstract\s+class"),
        "builder_pattern": re.compile(r"class\s+\w*Builder|\.build\s*\(\s*\)"),
        "method_chaining": re.compile(r"return\s+this\s*;?\s*$", re.MULTILINE),
        "add_listener": re.compile(r'\.addEventListener\s*\(|\.on\s*\([\'"]'),
        "remove_listener": re.compile(r'\.removeEventListener\s*\(|\.off\s*\([\'"]'),
        "callback_pyramid": re.compile(r"\)\s*=>\s*\{[^}]*\)\s*=>\s*\{[^}]*\)\s*=>\s*\{"),
    },
    "java": {
        "singleton_instance": re.compile(
            r"private\s+static\s+\w+\s+instance|getInstance\s*\(\s*\)"
        ),
        "eager_singleton": re.compile(r"private\s+static\s+final\s+\w+\s+INSTANCE\s*=\s*new"),
        "double_checked_locking": re.compile(
            r"synchronized.*?if\s*\(\s*instance\s*==\s*null\s*\)", re.DOTALL
        ),
        "god_class_methods": re.compile(
            r"^\s+(?:public|private|protected)\s+\w+\s+\w+\s*\(", re.MULTILINE
        ),
        "abstract_factory": re.compile(r"abstract\s+class\s+\w*Factory|interface\s+\w*Factory"),
        "factory_method": re.compile(r"(?:public|protected)\s+(?:static\s+)?\w+\s+create\w+\s*\("),
        "factory_if_chain": re.compile(
            r'if\s*\([^)]+\.equals\s*\([\'"][^\'"]+[\'"]\)\s*\)\s*\{?\s*return\s+new'
        ),
        "extends_class": re.compile(r"class\s+\w+\s+extends\s+\w+"),
        "implements_many": re.compile(r"implements\s+\w+\s*,\s*\w+\s*,\s*\w+\s*,\s*\w+"),
        "builder_class": re.compile(r"class\s+\w*Builder|public\s+\w+\s+build\s*\(\s*\)"),
        "fluent_setter": re.compile(r"public\s+\w+\s+set\w+\s*\([^)]+\)\s*\{[^}]*return\s+this"),
        "interface_explosion": re.compile(r"interface\s+I[A-Z]\w*"),
        "abstract_everything": re.compile(r"abstract\s+(?:class|void|int|String)"),
        "add_listener": re.compile(r"\.addListener\s*\(|\.subscribe\s*\("),
        "remove_listener": re.compile(r"\.removeListener\s*\(|\.unsubscribe\s*\("),
    },
    "go": {
        "sync_once": re.compile(r"sync\.Once|\.Do\s*\("),
        "global_var": re.compile(r"^var\s+[a-z]\w*\s+\*?\w+\s*$", re.MULTILINE),
        "init_function": re.compile(r"^func\s+init\s*\(\s*\)", re.MULTILINE),
        "god_struct_fields": re.compile(r"^\s+\w+\s+\w+", re.MULTILINE),
        "interface_explosion": re.compile(r"type\s+\w*er\s+interface"),
        "empty_interface": re.compile(r"interface\s*\{\s*\}"),
        "deep_embedding": re.compile(r"type\s+\w+\s+struct\s*\{[^}]*\w+\s*$", re.MULTILINE),
        "factory_new": re.compile(r"func\s+New\w+\s*\("),
        "unbuffered_channel": re.compile(r"make\s*\(\s*chan\s+\w+\s*\)"),
        "channel_leak": re.compile(r"go\s+func\s*\([^)]*\)\s*\{[^}]*<-", re.DOTALL),
    },
    "c": {
        "static_instance": re.compile(r"static\s+\w+\s*\*?\s*\w*instance|static\s+\w+\s+g_\w+"),
        "global_state": re.compile(r"^(?:static\s+)?\w+\s*\*?\s*g_\w+\s*[=;]", re.MULTILINE),
        "function_def": re.compile(r"^\w+\s+\w+\s*\([^)]*\)\s*\{", re.MULTILINE),
        "vtable_pattern": re.compile(r"struct\s*\{[^}]*\(\s*\*\s*\w+\s*\)\s*\([^)]*\)[^}]*\}"),
        "macro_function": re.compile(r"#define\s+\w+\s*\([^)]*\)\s+(?:\\\n|[^\n]){50,}"),
        "macro_magic": re.compile(r"#define\s+(?:FOR_EACH|FOREACH|DECLARE_|DEFINE_|IMPL_)"),
    },
    "cpp": {
        "meyers_singleton": re.compile(
            r"static\s+\w+&?\s+getInstance|static\s+\w+&\s+instance\s*\(\s*\)"
        ),
        "static_instance": re.compile(r"static\s+\w+\s*\*?\s*m?_?instance"),
        "god_class_methods": re.compile(
            r"^\s+(?:virtual\s+)?(?:\w+::)?\w+\s+\w+\s*\(", re.MULTILINE
        ),
        "template_explosion": re.compile(r"template\s*<[^>]*<[^>]*<"),
        "sfinae_abuse": re.compile(r"std::enable_if|std::void_t|decltype\s*\([^)]*\.\.\.\)"),
        "multiple_inheritance": re.compile(
            r"class\s+\w+\s*:\s*(?:public|private|protected)\s+\w+\s*,"
        ),
        "virtual_inheritance": re.compile(r"virtual\s+(?:public|private|protected)\s+\w+"),
        "diamond_problem": re.compile(r"class\s+\w+\s*:.*?virtual\s+(?:public|private|protected)"),
        "abstract_factory": re.compile(
            r"class\s+\w*(?:Abstract)?Factory|virtual\s+\w+\s*\*\s*create"
        ),
        "factory_method": re.compile(r"(?:static|virtual)\s+\w+\s*\*\s*(?:create|make)\w*\s*\("),
        "crtp_pattern": re.compile(r"class\s+(\w+)\s*:\s*(?:public|private)\s+\w+\s*<\s*\1\s*>"),
        "raw_new": re.compile(r"(?<!make_unique|make_shared)\s+new\s+\w+"),
        "shared_ptr_cycle": re.compile(r"shared_ptr.*?shared_ptr.*?shared_ptr", re.DOTALL),
    },
}


# =============================================================================
# DESIGN PATTERN DETECTOR
# =============================================================================


class DesignPatternDetector:
    """
    Detect misused design patterns that add complexity without benefit.
    """

    PATTERNS = DESIGN_PATTERNS

    # CALIBRATED thresholds based on analysis of 49 major open source projects
    # Previous thresholds flagged 98% of projects including Django, Flask, numpy, pandas
    THRESHOLDS = {
        "god_class_methods": 40,  # Raised from 20 - utility classes often have 25-35 methods
        "god_class_attrs": 25,  # Raised from 15 - dataclasses often have many fields
        "inheritance_depth": 5,  # Raised from 4 - frameworks often have deeper hierarchies
        "factory_types": 8,  # Raised from 5 - registries legitimately have many types
        "decorator_chain": 5,  # Raised from 4 - Flask/FastAPI routes often chain decorators
        "interface_count": 15,  # Raised from 10 - type-heavy code has many protocols
        "mixin_count": 5,  # Raised from 4 - Django models often use multiple mixins
        "builder_setters": 15,  # Raised from 10 - complex builders are OK
        "file_functions": 50,  # Raised from 30 - utility modules can be large
    }

    def detect(
        self, content: str, filepath: str, language: str
    ) -> tuple[list[DesignPatternIssue], list]:
        """Detect design pattern anti-patterns in code."""
        issues = []
        patterns_found = []

        lang_patterns = self.PATTERNS.get(language, {})
        if not lang_patterns:
            return issues, patterns_found

        if _is_generated_file(filepath, content):
            return issues, patterns_found

        is_test = _is_test_file(filepath)
        lines = content.split("\n")

        if not is_test:
            singleton_issues = self._check_singleton_abuse(
                content, filepath, language, lang_patterns, lines
            )
            issues.extend(singleton_issues)
            if singleton_issues:
                patterns_found.append("singleton")

        god_class_issues = self._check_god_class(
            content, filepath, language, lang_patterns, lines, is_test
        )
        issues.extend(god_class_issues)
        if god_class_issues:
            patterns_found.append("god_class")

        if not is_test:
            factory_issues = self._check_factory_abuse(
                content, filepath, language, lang_patterns, lines
            )
            issues.extend(factory_issues)
            if factory_issues:
                patterns_found.append("factory")

            inheritance_issues = self._check_inheritance_abuse(
                content, filepath, language, lang_patterns, lines
            )
            issues.extend(inheritance_issues)
            if inheritance_issues:
                patterns_found.append("inheritance")

            abstraction_issues = self._check_over_abstraction(
                content, filepath, language, lang_patterns, lines
            )
            issues.extend(abstraction_issues)
            if abstraction_issues:
                patterns_found.append("abstraction")

            observer_issues = self._check_observer_leaks(
                content, filepath, language, lang_patterns, lines
            )
            issues.extend(observer_issues)
            if observer_issues:
                patterns_found.append("observer")

            builder_issues = self._check_builder_bloat(
                content, filepath, language, lang_patterns, lines
            )
            issues.extend(builder_issues)
            if builder_issues:
                patterns_found.append("builder")

        if language == "cpp":
            cpp_issues = self._check_cpp_specific(content, filepath, lang_patterns, lines)
            issues.extend(cpp_issues)

        return issues, patterns_found

    def _find_line_number(self, content: str, match) -> int:
        """Find line number for a regex match."""
        return content[: match.start()].count("\n") + 1

    def _check_singleton_abuse(
        self, content: str, filepath: str, language: str, patterns: dict, lines: list
    ) -> list[DesignPatternIssue]:
        """Check for singleton anti-patterns."""
        issues = []

        if language == "python":
            if patterns.get("global_instance"):
                for match in patterns["global_instance"].finditer(content):
                    if not should_flag_match(content, match, filepath):
                        continue
                    line_num = self._find_line_number(content, match)
                    matched_text = match.group()
                    if not re.match(r'^[A-Z_]+\s*=\s*(?:True|False|None|\d+|[\'"])', matched_text):
                        issues.append(
                            DesignPatternIssue(
                                pattern_type="singleton_abuse",
                                severity="MEDIUM",
                                file=filepath,
                                line=line_num,
                                description="Global mutable singleton detected. Global state makes testing difficult.",
                                recommendation="Use dependency injection instead.",
                                code_snippet=matched_text[:100],
                            )
                        )

        elif language == "javascript":
            if patterns.get("global_singleton"):
                for match in patterns["global_singleton"].finditer(content):
                    if not should_flag_match(content, match, filepath):
                        continue
                    line_num = self._find_line_number(content, match)
                    issues.append(
                        DesignPatternIssue(
                            pattern_type="singleton_abuse",
                            severity="HIGH",
                            file=filepath,
                            line=line_num,
                            description="Global singleton via window/global object pollutes namespace.",
                            recommendation="Use module pattern or dependency injection.",
                            code_snippet=match.group()[:100],
                        )
                    )

        elif language == "java":
            if patterns.get("singleton_instance") and not patterns.get("double_checked_locking"):
                if patterns["singleton_instance"].search(content):
                    if "synchronized" not in content and "volatile" not in content:
                        for match in patterns["singleton_instance"].finditer(content):
                            if not should_flag_match(content, match, filepath):
                                continue
                            line_num = self._find_line_number(content, match)
                            issues.append(
                                DesignPatternIssue(
                                    pattern_type="singleton_abuse",
                                    severity="HIGH",
                                    file=filepath,
                                    line=line_num,
                                    description="Thread-unsafe singleton pattern.",
                                    recommendation="Use enum singleton or synchronized accessor.",
                                    code_snippet=match.group()[:100],
                                )
                            )

        return issues

    def _check_god_class(
        self,
        content: str,
        filepath: str,
        language: str,
        patterns: dict,
        lines: list,
        is_test: bool = False,
    ) -> list[DesignPatternIssue]:
        """Check for god classes with too many responsibilities."""
        issues = []
        method_threshold = self.THRESHOLDS["god_class_methods"] * (2 if is_test else 1)

        method_pattern = patterns.get("god_class_methods")
        if method_pattern:
            method_count = len(method_pattern.findall(content))
            if method_count > method_threshold:
                issues.append(
                    DesignPatternIssue(
                        pattern_type="god_class",
                        severity="LOW" if is_test else "HIGH",
                        file=filepath,
                        line=1,
                        description=f"God class: {method_count} methods (threshold: {method_threshold}).",
                        recommendation="Apply Single Responsibility Principle.",
                        code_snippet=f"{method_count} methods in file",
                    )
                )

        if not is_test and language == "python" and patterns.get("god_class_attrs"):
            attr_count = len(set(patterns["god_class_attrs"].findall(content)))
            if attr_count > self.THRESHOLDS["god_class_attrs"]:
                issues.append(
                    DesignPatternIssue(
                        pattern_type="god_class",
                        severity="MEDIUM",
                        file=filepath,
                        line=1,
                        description=f"Class has {attr_count} instance attributes.",
                        recommendation="Group related attributes into separate data classes.",
                        code_snippet=f"{attr_count} instance attributes",
                    )
                )

        return issues

    def _check_factory_abuse(
        self, content: str, filepath: str, language: str, patterns: dict, lines: list
    ) -> list[DesignPatternIssue]:
        """Check for factory pattern anti-patterns."""
        issues = []

        factory_if_pattern = patterns.get("factory_if_chain")
        if factory_if_pattern:
            matches = [
                m
                for m in factory_if_pattern.finditer(content)
                if should_flag_match(content, m, filepath)
            ]
            if len(matches) >= 3:
                for match in matches[:1]:
                    line_num = self._find_line_number(content, match)
                    issues.append(
                        DesignPatternIssue(
                            pattern_type="factory_overkill",
                            severity="MEDIUM",
                            file=filepath,
                            line=line_num,
                            description="Factory with if/switch chain.",
                            recommendation="Use registry pattern or polymorphic factory.",
                            code_snippet=match.group()[:150],
                        )
                    )

        if "FactoryFactory" in content or "AbstractAbstract" in content:
            issues.append(
                DesignPatternIssue(
                    pattern_type="factory_overkill",
                    severity="HIGH",
                    file=filepath,
                    line=1,
                    description="Over-abstracted factory pattern (FactoryFactory).",
                    recommendation="Simplify the design.",
                    code_snippet="FactoryFactory pattern detected",
                )
            )

        return issues

    def _check_inheritance_abuse(
        self, content: str, filepath: str, language: str, patterns: dict, lines: list
    ) -> list[DesignPatternIssue]:
        """Check for inheritance hierarchy abuse."""
        issues = []

        if language == "python" and patterns.get("mixin_explosion"):
            for match in patterns["mixin_explosion"].finditer(content):
                if not should_flag_match(content, match, filepath):
                    continue
                line_num = self._find_line_number(content, match)
                parents = match.group().count(",") + 1
                if parents > self.THRESHOLDS["mixin_count"]:
                    issues.append(
                        DesignPatternIssue(
                            pattern_type="inheritance_abuse",
                            severity="MEDIUM",
                            file=filepath,
                            line=line_num,
                            description=f"Class inherits from {parents} parents.",
                            recommendation="Prefer composition over inheritance.",
                            code_snippet=match.group()[:100],
                        )
                    )

        if language == "cpp" and patterns.get("multiple_inheritance"):
            for match in patterns["multiple_inheritance"].finditer(content):
                if not should_flag_match(content, match, filepath):
                    continue
                line_num = self._find_line_number(content, match)
                issues.append(
                    DesignPatternIssue(
                        pattern_type="inheritance_abuse",
                        severity="MEDIUM",
                        file=filepath,
                        line=line_num,
                        description="Multiple inheritance detected.",
                        recommendation="Use composition or interface inheritance.",
                        code_snippet=match.group()[:100],
                    )
                )

        return issues

    def _check_over_abstraction(
        self, content: str, filepath: str, language: str, patterns: dict, lines: list
    ) -> list[DesignPatternIssue]:
        """Check for over-abstraction and interface explosion."""
        issues = []

        interface_pattern = patterns.get("interface_explosion")
        if interface_pattern:
            matches = [
                m
                for m in interface_pattern.finditer(content)
                if should_flag_match(content, m, filepath)
            ]
            if len(matches) > self.THRESHOLDS["interface_count"]:
                issues.append(
                    DesignPatternIssue(
                        pattern_type="over_abstraction",
                        severity="MEDIUM",
                        file=filepath,
                        line=1,
                        description=f"Interface explosion: {len(matches)} interfaces.",
                        recommendation="Only create interfaces when needed.",
                        code_snippet=f"{len(matches)} interfaces defined",
                    )
                )

        if language == "python":
            abstract_pattern = patterns.get("abstract_everything")
            if abstract_pattern:
                abstract_count = len(abstract_pattern.findall(content))
                if abstract_count > 5:
                    issues.append(
                        DesignPatternIssue(
                            pattern_type="over_abstraction",
                            severity="LOW",
                            file=filepath,
                            line=1,
                            description=f"Heavy use of ABC ({abstract_count} occurrences).",
                            recommendation="Consider using Protocol for structural subtyping.",
                            code_snippet=f"{abstract_count} ABC/abstractmethod uses",
                        )
                    )

        return issues

    def _check_observer_leaks(
        self, content: str, filepath: str, language: str, patterns: dict, lines: list
    ) -> list[DesignPatternIssue]:
        """Check for observer pattern memory leak potential."""
        issues = []

        subscribe_pattern = patterns.get("observer_subscribe") or patterns.get("add_listener")
        unsubscribe_pattern = patterns.get("observer_unsubscribe") or patterns.get(
            "remove_listener"
        )

        if subscribe_pattern and unsubscribe_pattern:
            subscribe_count = len(subscribe_pattern.findall(content))
            unsubscribe_count = len(unsubscribe_pattern.findall(content))

            if subscribe_count > 0 and unsubscribe_count == 0:
                issues.append(
                    DesignPatternIssue(
                        pattern_type="observer_leak",
                        severity="HIGH",
                        file=filepath,
                        line=1,
                        description=f"Observer leak: {subscribe_count} subscriptions, no unsubscriptions.",
                        recommendation="Always unsubscribe in cleanup methods.",
                        code_snippet=f"{subscribe_count} subscribe, 0 unsubscribe",
                    )
                )

        return issues

    def _check_builder_bloat(
        self, content: str, filepath: str, language: str, patterns: dict, lines: list
    ) -> list[DesignPatternIssue]:
        """Check for builder pattern overuse."""
        issues = []

        builder_pattern = patterns.get("builder_pattern")
        if builder_pattern and builder_pattern.search(content):
            setter_count = 0
            if language == "python":
                setter_count = len(re.findall(r"def\s+set_\w+|def\s+with_\w+", content))
            elif language in ("java", "javascript"):
                setter_count = len(re.findall(r"(?:public|set)\w+\s*\(|\.set\w+\s*\(", content))

            if 1 <= setter_count <= 3:
                issues.append(
                    DesignPatternIssue(
                        pattern_type="builder_bloat",
                        severity="LOW",
                        file=filepath,
                        line=1,
                        description=f"Builder for simple object ({setter_count} setters).",
                        recommendation="Use constructor with named arguments.",
                        code_snippet=f"Builder with {setter_count} setters",
                    )
                )

        return issues

    def _check_cpp_specific(
        self, content: str, filepath: str, patterns: dict, lines: list
    ) -> list[DesignPatternIssue]:
        """C++ specific pattern checks."""
        issues = []

        if patterns.get("raw_new"):
            raw_news = [
                m
                for m in patterns["raw_new"].finditer(content)
                if should_flag_match(content, m, filepath)
            ]
            smart_ptr_count = len(
                re.findall(r"unique_ptr|shared_ptr|make_unique|make_shared", content)
            )

            if len(raw_news) > smart_ptr_count and len(raw_news) > 3:
                issues.append(
                    DesignPatternIssue(
                        pattern_type="memory_management",
                        severity="HIGH",
                        file=filepath,
                        line=self._find_line_number(content, raw_news[0]) if raw_news else 1,
                        description=f"Raw new without smart pointers ({len(raw_news)} vs {smart_ptr_count}).",
                        recommendation="Use std::unique_ptr or std::shared_ptr.",
                        code_snippet=raw_news[0].group()[:50] if raw_news else "",
                    )
                )

        if patterns.get("template_explosion"):
            for match in patterns["template_explosion"].finditer(content):
                if not should_flag_match(content, match, filepath):
                    continue
                line_num = self._find_line_number(content, match)
                issues.append(
                    DesignPatternIssue(
                        pattern_type="template_abuse",
                        severity="MEDIUM",
                        file=filepath,
                        line=line_num,
                        description="Deeply nested templates.",
                        recommendation="Simplify template hierarchy.",
                        code_snippet=match.group()[:100],
                    )
                )

        return issues


__all__ = ["DesignPatternDetector", "DesignPatternIssue", "DESIGN_PATTERNS"]
